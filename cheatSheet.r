#------------------------------------- R -------------------------------------#

# µ - Alt + 0181
# https://cran.r-project.org/doc/contrib/Short-refcard.pdf
# https://towardsdatascience.com/all-probability-distributions-explained-in-six-minutes-fe57b1d49600

# !!! https://willdrevo.com/r-language-cheatsheet !!!
# https://www.stat.umn.edu/geyer/old/5101/rlook.html

#---------------------------------- Пакети ----------------------------------#

# install.packages('UsingR') - инсталиране на пакети
# library('UsingR') - зареждане на пакет
# load(data) - зареждане на данни от пакет
# ?cancer - дава информация какво представлява извадката от данни

#------------------------------ Основни функции ------------------------------#

# x = 3 == x <- 3 == x -> 3
# x ->> 3 (присвояване с глобален обхват)
# 'hello' == print('hello')
# data types : numeric, integer, complex, character, logical
# class(x) == typeof(x)
# sqrt(x), abs(x), ceiling(x), floor(x)
# nchar(x) == length(x)
# grepl('hello', x) - търси подниз в низ
# paste(x, y) == concatenate(x, y)
# my_function <- function(x) { print(x) } ; my_function()

#                                   Оператори
# +, -, *, /, %/% (целочислено деление), ^, %% (деление по модул)
# ==, !=, >, <, >=, <=
# &, &&, |, ||, !
# : (създаване на последователност от числа), %in% (търсене на елемент в множество), 
# %*% (умножение на матрици)

#                               Вектори и матрици
# [4] - връща 4-тия елемент
# [-4] - връща всички освен 4-тия елемент
# [2:4] - връща от 2-рия до 4-тия елемент
# [-(2:4)] - връща всички освен от 2-рия до 4-тия елемент
# [c(1, 5)] - връща елементи 1 и 5
# [x %in% c(1, 2, 5)] - търси елемент в множество

# cbind(x) - добавя колона към матрица
# rbind(x) - добавя ред към матрица
# c(a, ..., z) - създава вектор от стойности
# matrix(vector, nrow = n, ncol = m, dimnames = list(c('a', 'b', 'c'))) - създава матрица
# data.frame(x, y, ...) - създаване на таблица със стойности (подобно на таблица от база от данни)
# sort(x), length(x)
# sum(x), cumsum(x), mean(x), cummean(x), median(x)
# quantile(x, probs = ...) - прави извадка на квантили, съответстващи на дадените вероятности
# по подразбиране са 0.25 - първи квантил, 0.75 - четвърти квантил и т.н.
# sd(x) - стандартно отклонение
# summary(x) - връща информация за минимум, максимум, мода, медиана и др.
# replicate(x, times) - times брой пъти прави копие на x
# sample(vector, size = ..., replace = T/F, prob = c(...)) - прави симулация на експеримент 

#                               Визуализиране на данни

# table(x) - представя таблица с числа и техните честоти
# prop.table(x) - изчислява стойността на всяка клетка в таблица като пропорция
# на всички стойности
# plot(x, y, ...) - рисува точки(маркери) в диаграма
# barplot(x) - рисува вертикална лентова диаграма
# boxplot(x) - рисува боксплот
# hist(x, probability = T) - рисува хистограма
# lines(density(x)) - рисува линия, която минава по стойностите на хистограмата, 
# показва се само ако при hist имаме аргумент probability = T
# qqnorm(x) - рисува графика (квантили на x по отношение на очакваните стойности съгласно 
# нормален закон)
# qqlines(x, y) - рисува линия по графика (квантилите на y по отношение на квантилите на x)

#                                 Тестване на данни

# t.test(x, y, var.equal = T, alternative = 'less') - прави t-тест за разлика между моди
# prop.test(x, n, p = NULL, alternative = c("two.sided", "less", "greater"), conf.level = 0.95,
#          correct = T) - тества за разлика между пропорции
# shapiro.test(x) - прави тест за нормално разпределение по метода на Шапиро-Уилк, основава се 
# на корелацията между данните и съоветните нормални резултати
# wilcox.test(x, conf.int = T/F, conf.level = 0.96) - прави тест на Уилкоксън
# алтернатива на t-test за сравнение на две моди, използва се когато данните не са нормално
# разпределени

#------------------------------- Разпределения -------------------------------#

# r{function} - емпирична вероятност (random variates), симулиране на случайна величина 
# d{function} - теоретична вероятност (probability density)
# p{function} - кумулативна вероятност (cumulative probability)
# q{function} - стойност на квантилите (quantile)

# В задачи:
# Направете произволна извадка на ... -> ползваме r{function}
# Покажете "височината" ... за конкретен резултат -> ползваме d{function}
# Каква е вероятността ... -> ползваме p{function}
# Каква е стойността на X% от ... -> ползваме q{function}

# Дискретни разпределения #

# Дискретно разпределение - променливите приемат ограничен брой стойности в даден диапазон

# Биномно разпределение - описва резултат от сценарии с два изхода (хвърляне на монета)
# n - брой наблюдения, size - брой опити, prob - вероятността за успех при всеки опит, 
# x - вектор от числа, p - вектор от вероятности
# rbinom(n, size, prob)
# dbinom(x, size, prob, log = T/F)  
# pbinom(q, size, prob, lower.tail = T/F, log.p = T/F)  
# qbinom(p, size, prob, lower.tail = T/F, log.p = T/F)

# Поасоново разпределение - изчислява колко пъти дадено събитие може да се случи за определено
# време (ако някой яде два пъти на ден, каква е вероятността да яде три пъти?)
# n - брой наблюдения, lambda - среден процент на успех, x - брой успехи, q - брой успехи
# p - процентили
# rpois(n, lambda) 
# dpois(x, lambda, log = T/F) 
# ppois(q, lambda, lower.tail = T/F, log.p = T/F) 
# qpois(p, lambda, lower.tail = T/F, log.p = T/F) 

# Геометрично разпределение - описва брой неуспешни опити до първия успех
# n - брой неупсехи до първия успех, prob - вероятността за успех при всеки опит, 
# x - брой неуспехи до първия успех, q - брой неуспехи до първия успех, 
# p - вектор от вероятности
# rgeom(n, prob) 
# dgeom(x, prob, log = T/F) 
# pgeom(q, prob, lower.tail = T/F, log.p = T/F) 
# qgeom(p, prob, lower.tail = T/F, log.p = T/F)

# Отрицателно биномно разпределение - 
# n - брой наблюдения, size - брой успешни опити, prob - вероятността за успех при всеки опит
# x - вектор от квантили, q - вектор от квантили, mu - алтернативна параметризация чрез средна 
# стойност
# rnbinom(n, size, prob, mu) 
# dnbinom(x, size, prob, mu, log = T/F)
# pnbinom(q, size, prob, mu, lower.tail = T/F, log.p = T/F)
# qnbinom(p, size, prob, mu, lower.tail = T/F, log.p = T/F)

# Хипергеометрично разпределение - описва вероятността от n обекта, k да са ... и m да са ...
# nn - брой наблюдения, m - броя на {белите/дефектните/т.н.} обекти, 
# n - броя на {черните/недефектни/т.н} обекти, k - броя на обектите, които са извадени,
# x - вектор на квантилите, q - вектор на квантилите, p - вероятността
# rhyper(nn, m, n, k)
# dhyper(x, m, n, k, log = T/F)
# phyper(q, m, n, k, lower.tail = T/F, log.p = T/F)
# qhyper(p, m, n, k, lower.tail = T/F, log.p = T/F)

# Непрекъснати разпределения #

# Непрекъснато разпределение - променливите могат да приемат всяка стойност в даден диапазон 

# Нормално (Гаусово) разпределение
# n - брой наблюдения (дължина на извадката), mean - средно аритметично (default = 0), 
# sd - стандартно отклонение (default = 1), x - вектор от числа, p - вектор от вероятности
# rnorm(n, mean = 0, sd = 1)
# dnorm(x, mean = 0, sd = 1, log = T/F)
# pnorm(q, mean = 0, sd = 1, lower.tail = T/F, log = T/F)
# qnorm(p, mean = 0, sd = 1, lower.tail = T/F, log = T/F)

# Eкспоненциално разпределение - моделира периода от време, който трябва да се изчака преди 
# дадено събитие да се случи
# n - брой наблюдения, rate - скорост на събитието (default = 1)
# rexp(n, rate = 1)
# dexp(x, rate = 1, log = T/F)
# pexp(q, rate = 1, lower.tail = T/F, log.p = T/F)
# qexp(p, rate = 1, lower.tail = T/F, log.p = T/F)

# Равномерно разпределение - описва вероятност, при която всяко събитие има равни шансове да
# се случи (хвърляне на зарче)
# n - брой наблюдения, min - долна граница (default = 0.0), max - горна граница (default = 1.0)
# runif(n, min = 0, max = 1)
# dunif(x, min = 0, max = 1, log = T/F)
# punif(q, min = 0, max = 1, lower.tail = T/F, log.p = T/F)
# qunif(p, min = 0, max = 1, lower.tail = T/F, log.p = T/F)

# T-разпределение
# t.test(x) - опит да се оцени средната стойност на нормално разпределение с различни по
# размер извадки, полезно при описване на грешка на оценката
# тества хипотези

#-----------------------------------------------------------------------------# 

# Как се разпознава нормално разпределение:
# I начин - чрез хистограма, наподобява ли биномно?, слагаме данни на плътността
# II начин - boxplot(), тогава е симетричен около медианата
# III начин - qqnorm(), qqline() - линия от вектори
# IV начин - shapirotest(x), дали x идва от нормално разпределение

# shapiro -> тества дали разпределението е нормално
# горе-долу след 30 наблюдения, разпределението се нормализира -> n > 30 -> t.test()
# ако не е -> wilcox.test
# ако в условието има проценти -> prop.test
# тестване на равномерно разпределение -> chisq.test

# pvalue - вероятността да наблюдаваме, това което сме наблюдавали при допускане, че 
# хипотеза 0 е вярна
# alfa = 0.05, pvalue = 0.06, alfa < pvalue -> не отхвърляме нулевата хипотеза
# alfa = 0.10, pvalue = 0.06, alfa > pvalue -> отхвърляме нулевата хипотеза

# за да визуализираме данните и да се опитаме да определим дали са нормално разпределени
# qqplot - за една променлива
# boxplot - за много променливи

# пресметнете корелацията -> cor()
# представете графично:
#   категорни данни    - barplot(), prop.table(table())
#   непрекъснати данни - hist(), lines(density())
# 

#                        Теми
# Категорни данни
# Числови данни
# Симулации
# Дискретни случайни величини
# Непрекъснати случайни величини
# Доверителни интервали
# Тестване на хипотези с една извадка
# Тестване за еднородност
# Хи квадрат тестове
# Линейна регресия
# Регресия с много променливи
# Логистична регресия
# Дисперсионен анализ